/*
 * Pyx4j framework
 * Copyright (C) 2008-2011 pyx4j.com.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 * Created on Feb 9, 2012
 * @author vlads
 */
package com.pyx4j.entity.rdb.mapping;

import java.util.Collection;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.pyx4j.entity.annotations.AbstractEntity;
import com.pyx4j.entity.annotations.ColumnId;
import com.pyx4j.entity.annotations.Inheritance;
import com.pyx4j.entity.annotations.JoinColumn;
import com.pyx4j.entity.annotations.JoinTable;
import com.pyx4j.entity.annotations.Table;
import com.pyx4j.entity.core.EntityFactory;
import com.pyx4j.entity.core.IEntity;
import com.pyx4j.entity.core.ObjectClassType;
import com.pyx4j.entity.core.meta.EntityMeta;
import com.pyx4j.entity.core.meta.MemberMeta;
import com.pyx4j.entity.rdb.dialect.Dialect;

class JoinTableInformation extends JoinInformation {

    private static final Logger log = LoggerFactory.getLogger(JoinTableInformation.class);

    private final EntityMeta rootEntityMeta;

    private final EntityMeta entityMeta;

    private final MemberMeta memberMeta;

    private final JoinTable joinTable;

    JoinTableInformation(Dialect dialect, EntityMeta rootEntityMeta, EntityMeta entityMeta, MemberMeta memberMeta) {
        this.rootEntityMeta = rootEntityMeta;
        this.entityMeta = entityMeta;
        this.memberMeta = memberMeta;
        this.joinTable = memberMeta.getAnnotation(JoinTable.class);

        @SuppressWarnings("unchecked")
        Class<? extends IEntity> entityClass = (Class<IEntity>) memberMeta.getValueClass();
        Class<? extends IEntity> joinEntityClass = joinTable.value();
        if ((joinEntityClass.getAnnotation(AbstractEntity.class) != null) && (joinEntityClass.getAnnotation(Inheritance.class) == null)) {
            Collection<Class<? extends IEntity>> subclassed = Mappings.getPersistableAssignableFrom(joinEntityClass);
            assert subclassed.size() == 1 : "Only one Persistable Type is supported in @JoinTable.value for hierarchy of " + joinEntityClass;
            joinEntityClass = subclassed.iterator().next();
        }
        EntityMeta joinEntityMeta = EntityFactory.getEntityMeta(joinEntityClass);
        MemberMeta ownerMemberMeta = findOwnerMember(joinEntityMeta);

        switch (ownerMemberMeta.getObjectClassType()) {
        case Entity:
            sqlName = TableModel.getTableName(dialect, joinEntityMeta);
            joinTableClass = joinEntityClass;
            if ((joinEntityClass == entityClass) || (joinEntityClass.isAssignableFrom(entityClass))) {
                sqlValueName = dialect.getNamingConvention().sqlIdColumnName();
                joinTableSameAsTarget = true;
            } else {
                sqlValueName = dialect.getNamingConvention()
                        .sqlFieldName(EntityOperationsMeta.memberPersistenceName(findValueMember(joinEntityMeta, entityClass)));
                joinTableSameAsTarget = false;
            }
            sqlOwnerName = dialect.getNamingConvention().sqlFieldName(EntityOperationsMeta.memberPersistenceName(ownerMemberMeta));
            ownerValueAdapter = EntityOperationsMeta.createEntityValueAdapter(dialect, rootEntityMeta, ownerMemberMeta);
            break;
        case EntityList:
        case EntitySet:
            // One-to-Many, JT auto generated
            joinTableClass = joinEntityClass;
            joinTableSameAsTarget = false;
            sqlName = dialect.getNamingConvention().sqlChildTableName(joinEntityMeta.getPersistenceName(),
                    EntityOperationsMeta.memberPersistenceName(ownerMemberMeta));
            sqlValueName = dialect.getNamingConvention().sqlAutoGeneratedJoinOwnerColumnName();
            sqlOwnerName = dialect.getNamingConvention().sqlAutoGeneratedJoinValueColumnName();
            ownerValueAdapter = EntityOperationsMeta.createEntityValueAdapter(dialect, rootEntityMeta, ownerMemberMeta);
            break;
        default:
            throw new AssertionError();
        }

        MemberMeta orderMemberMeta = MemberCollectionOrderMeta.findOrderMember(entityMeta, memberMeta, true, joinEntityMeta);

        if (orderMemberMeta == null && memberMeta.getObjectClassType() == ObjectClassType.EntityList) {
            throw new AssertionError("Unmapped @OrderBy member in join table " + joinEntityMeta.getEntityClass().getName() + " for '"
                    + memberMeta.getFieldName() + "' in " + entityMeta.getEntityClass().getName());
        } else if (orderMemberMeta != null) {
            collectionOrderMeta = new MemberCollectionOrderMeta(dialect, orderMemberMeta);
        }

        if (EntityFactory.getEntityMeta(entityClass).getPersistableSuperClass() != null) {
            sqlChildJoinContition.add(buildPolymorphicChildJoinContition(dialect, entityClass));
        }
        if (joinTable.where().length != 0) {
            sqlChildJoinContition.addAll(buildChildJoinWhereContition(dialect, entityClass, joinTable.where()));
        }
    }

    private MemberMeta findOwnerMember(EntityMeta joinEntityMeta) {
        MemberMeta ownerMemberMeta = null;

        Class<? extends IEntity> rootEntityClass = rootEntityMeta.getEntityClass();
        Table tableAnnotation = rootEntityMeta.getAnnotation(Table.class);
        if ((tableAnnotation != null) && (tableAnnotation.expands() != IEntity.class)) {
            rootEntityClass = tableAnnotation.expands();
        }

        for (String jmemberName : joinEntityMeta.getMemberNames()) {
            MemberMeta jmemberMeta = joinEntityMeta.getMemberMeta(jmemberName);
            if (!jmemberMeta.isTransient()) {
                if ((joinTable.mappedBy() == ColumnId.class)
                        && ((jmemberMeta.getObjectClass().equals(rootEntityMeta.getEntityClass())) || (jmemberMeta.getObjectClass().equals(rootEntityClass)))) {
                    ownerMemberMeta = jmemberMeta;
                } else {
                    JoinColumn joinColumn = jmemberMeta.getAnnotation(JoinColumn.class);
                    if (joinColumn != null) {
                        if (joinTable.mappedBy() != ColumnId.class) {
                            if (joinColumn.value() == joinTable.mappedBy()) {
                                ownerMemberMeta = jmemberMeta;
                                break;
                            }
                        } else {
                            if (joinColumn.value() == ColumnId.class) {
                                if ((jmemberMeta.getObjectClass().isAssignableFrom(rootEntityMeta.getEntityClass()))
                                        || (jmemberMeta.getObjectClass().isAssignableFrom(rootEntityClass))) {
                                    ownerMemberMeta = jmemberMeta;
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        }
        if (ownerMemberMeta == null) {
            throw new AssertionError("Unmapped owner member in join table '" + joinEntityMeta.getCaption() + "' for '" + memberMeta.getFieldName() + "' in "
                    + entityMeta.getEntityClass().getName());
        } else {
            return ownerMemberMeta;
        }
    }

    private MemberMeta findValueMember(EntityMeta joinEntityMeta, Class<? extends IEntity> entityClass) {
        MemberMeta valueMemberMeta = null;

        for (String jmemberName : joinEntityMeta.getMemberNames()) {
            MemberMeta jmemberMeta = joinEntityMeta.getMemberMeta(jmemberName);
            if (!jmemberMeta.isTransient()) {
                if (jmemberMeta.getValueClass().equals(entityClass) || (jmemberMeta.getValueClass().isAssignableFrom(entityClass))) {
                    valueMemberMeta = jmemberMeta;
                    break;
                }
            }
        }
        if (valueMemberMeta == null) {
            log.warn("Existing Members in Join Table: {}", joinEntityMeta.getEntityClass().getSimpleName());
            for (String jmemberName : joinEntityMeta.getMemberNames()) {
                MemberMeta jmemberMeta = joinEntityMeta.getMemberMeta(jmemberName);
                if (!jmemberMeta.isTransient()) {
                    log.warn("   {} {}", jmemberName, jmemberMeta.getValueClass());
                }
            }

            throw new AssertionError("Unmapped value member of class '" + entityClass.getName() + "' in join table '" + joinEntityMeta.getCaption()
                    + "\n' to map field '" + memberMeta.getFieldName() + "' in  table " + entityMeta.getEntityClass().getName());
        } else {
            return valueMemberMeta;
        }
    }

}