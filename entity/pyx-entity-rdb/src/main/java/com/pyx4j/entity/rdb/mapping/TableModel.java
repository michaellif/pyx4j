/*
 * Pyx4j framework
 * Copyright (C) 2008-2010 pyx4j.com.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not
 * use this file except in compliance with the License. You may obtain a copy of
 * the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 *
 * Created on 2010-07-08
 * @author vlads
 * @version $Id$
 */
package com.pyx4j.entity.rdb.mapping;

import java.io.Serializable;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.SQLNonTransientConnectionException;
import java.sql.Statement;
import java.util.Calendar;
import java.util.GregorianCalendar;
import java.util.List;
import java.util.Map;
import java.util.Vector;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.pyx4j.commons.Key;
import com.pyx4j.config.server.Trace;
import com.pyx4j.entity.annotations.AbstractEntity;
import com.pyx4j.entity.annotations.DiscriminatorValue;
import com.pyx4j.entity.annotations.Indexed;
import com.pyx4j.entity.annotations.Inheritance;
import com.pyx4j.entity.annotations.Table;
import com.pyx4j.entity.annotations.Table.PrimaryKeyStrategy;
import com.pyx4j.entity.annotations.validator.NotNull;
import com.pyx4j.entity.core.AttachLevel;
import com.pyx4j.entity.core.EntityFactory;
import com.pyx4j.entity.core.ICollection;
import com.pyx4j.entity.core.IEntity;
import com.pyx4j.entity.core.ObjectClassType;
import com.pyx4j.entity.core.Path;
import com.pyx4j.entity.core.criterion.EntityListCriteria;
import com.pyx4j.entity.core.criterion.EntityQueryCriteria;
import com.pyx4j.entity.core.meta.EntityMeta;
import com.pyx4j.entity.core.meta.MemberMeta;
import com.pyx4j.entity.rdb.EntityPersistenceServiceRDB;
import com.pyx4j.entity.rdb.PersistenceContext;
import com.pyx4j.entity.rdb.PersistenceTrace;
import com.pyx4j.entity.rdb.SQLUtils;
import com.pyx4j.entity.rdb.cfg.Configuration.Ddl;
import com.pyx4j.entity.rdb.dialect.Dialect;
import com.pyx4j.entity.rdb.dialect.SQLAggregateFunctions;
import com.pyx4j.entity.shared.IntegrityConstraintUserRuntimeException;
import com.pyx4j.entity.shared.UniqueConstraintUserRuntimeException;
import com.pyx4j.i18n.shared.I18n;
import com.pyx4j.server.contexts.NamespaceManager;

public class TableModel {

    public static final int ORDINARY_STRING_LENGHT_MAX = 500;

    public static final int ENUM_STRING_LENGHT_MAX = 50;

    private static final Logger log = LoggerFactory.getLogger(TableModel.class);

    private static final I18n i18n = I18n.get(TableModel.class);

    final String tableName;

    private final Dialect dialect;

    private final Mappings mappings;

    private final EntityMeta entityMeta;

    enum ModelType {

        regular,

        subclass,

        superclass

    }

    final ModelType classModel;

    private final EntityOperationsMeta entityOperationsMeta;

    private final PrimaryKeyStrategy primaryKeyStrategy;

    private final int autoGeneratedKeys;

    private String sqlInsert;

    private String sqlUpdate;

    public TableModel(Dialect dialect, Mappings mappings, EntityMeta entityMeta) {
        this.dialect = dialect;
        this.mappings = mappings;
        this.entityMeta = entityMeta;

        Inheritance inheritance = entityMeta.getAnnotation(Inheritance.class);
        if ((inheritance != null) && (inheritance.strategy() != Inheritance.InheritanceStrategy.TABLE_PER_CLASS)) {
            classModel = ModelType.superclass;
        } else if (entityMeta.getPersistableSuperClass() != null) {
            if (entityMeta.getEntityClass().getAnnotation(AbstractEntity.class) != null) {
                classModel = ModelType.superclass;
            } else {
                classModel = ModelType.subclass;
            }
        } else {
            classModel = ModelType.regular;
        }

        if ((classModel != ModelType.superclass) && entityMeta.getEntityClass().getAnnotation(AbstractEntity.class) != null) {
            throw new Error("Persistence of @AbstractEntity " + entityMeta.getEntityClass().getName() + " is not permitted");
        }

        Table tableAnnotation = entityMeta.getEntityClass().getAnnotation(Table.class);
        if (tableAnnotation != null) {
            primaryKeyStrategy = tableAnnotation.primaryKeyStrategy();
        } else {
            primaryKeyStrategy = Table.PrimaryKeyStrategy.AUTO;
        }
        tableName = getTableName(dialect, entityMeta);
        entityOperationsMeta = new EntityOperationsMeta(dialect, entityMeta);

        if (dialect.isSequencesBaseIdentity()) {
            for (MemberOperationsMeta member : entityOperationsMeta.getCollectionMembers()) {
                member.setSqlSequenceName(dialect.getNamingConvention().sqlChildTableSequenceName(member.sqlName()));
            }
        }

        if (getPrimaryKeyStrategy() == Table.PrimaryKeyStrategy.ASSIGNED) {
            autoGeneratedKeys = Statement.NO_GENERATED_KEYS;
        } else {
            autoGeneratedKeys = Statement.RETURN_GENERATED_KEYS;
        }
    }

    public static String getTableName(Dialect dialect, EntityMeta entityMeta) {
        return dialect.getNamingConvention().sqlTableName(entityMeta.getPersistenceName());
    }

    public String getTableName() {
        return tableName;
    }

    public String getFullTableName() {
        return getFullTableName(this.tableName);
    }

    public String getFullTableName(String tableName) {
        if (dialect.isMultitenantSeparateSchemas()) {
            assert NamespaceManager.getNamespace() != null : "Namespace is required";
            return NamespaceManager.getNamespace() + "." + tableName;
        } else if (mappings.getConfiguration().forceQualifiedNames()) {
            return mappings.getConfiguration().tablesSchema() + "." + tableName;
        } else {
            return tableName;
        }
    }

    public boolean ensureExists(PersistenceContext persistenceContext, Ddl ddl) throws SQLException {
        if (ddl == Ddl.disabled) {
            return false;
        }

        boolean tableCreated = false;
        {
            if (Mappings.traceInit) {
                log.trace(Trace.id() + "getTableMetadata {}", tableName);
            }
            TableMetadata tableMetadata = TableMetadata.getTableMetadata(persistenceContext, mappings.getConfiguration(), tableName);
            if (tableMetadata == null) {
                log.debug("table {} does not exists", tableName);
                switch (ddl) {
                case auto:
                    SQLUtils.execute(persistenceContext.getConnection(), TableDDL.sqlCreate(dialect, this, this.mappings.getConfiguration()));
                    if (Mappings.traceInit) {
                        log.trace(Trace.id() + "table created {}", tableName);
                    }
                    tableCreated = true;
                    break;
                case disabled:
                    // ignore
                    break;
                case validate:
                    throw new Error("Table '" + tableName + "' does not exists");
                }
            } else {
                List<String> sqlChanges = TableDDL.validateAndAlter(dialect, tableMetadata, this);
                switch (ddl) {
                case auto:
                    SQLUtils.execute(persistenceContext.getConnection(), sqlChanges);
                    break;
                case disabled:
                    // ignore
                    break;
                case validate:
                    log.error("DLL operations required {}", sqlChanges);
                    throw new Error("Table '" + tableName + "' requires structural changes");
                }
            }
        }

        for (MemberOperationsMeta member : entityOperationsMeta.getAutogeneratedCollectionMembers()) {
            TableMetadata memberTableMetadata = TableMetadata.getTableMetadata(persistenceContext, mappings.getConfiguration(), member.sqlName());
            if (memberTableMetadata == null) {
                switch (ddl) {
                case auto:
                    SQLUtils.execute(persistenceContext.getConnection(),
                            TableDDL.sqlCreateCollectionMember(dialect, this, member, this.mappings.getConfiguration()));
                    tableCreated = true;
                    break;
                case disabled:
                    // ignore
                    break;
                case validate:
                    throw new Error("Table '" + member.sqlName() + "' does not exists");
                }
            } else {
                List<String> sqlChanges = TableDDL.validateAndAlterCollectionMember(dialect, this, memberTableMetadata, member);
                switch (ddl) {
                case auto:
                    SQLUtils.execute(persistenceContext.getConnection(), sqlChanges);
                    break;
                case disabled:
                    // ignore
                    break;
                case validate:
                    log.error("DLL operations required {}", sqlChanges);
                    throw new Error("Table '" + member.sqlName() + "' requires structural changes");
                }
            }
        }
        return tableCreated;
    }

    public void ensureForeignKeys(PersistenceContext persistenceContext) throws SQLException {
        TableMetadata tableMetadata = TableMetadata.getTableMetadata(persistenceContext, mappings.getConfiguration(), tableName);
        tableMetadata.readForeignKeys(persistenceContext);
        for (MemberOperationsMeta member : operationsMeta().getColumnMembers()) {
            if (!member.getMemberMeta().isEntity()) {
                continue;
            }
            @SuppressWarnings("unchecked")
            Class<? extends IEntity> entityClass = (Class<IEntity>) member.getMemberMeta().getValueClass();
            EntityMeta entityMeta = EntityFactory.getEntityMeta(entityClass);
            if (entityMeta.getPersistableSuperClass() != null) {
                entityClass = entityMeta.getPersistableSuperClass();
                entityMeta = EntityFactory.getEntityMeta(entityClass);
            }
            Inheritance inheritance = entityClass.getAnnotation(Inheritance.class);
            if ((inheritance != null) && (inheritance.strategy() != Inheritance.InheritanceStrategy.SINGLE_TABLE)) {
                continue;
            }

            String refSqlTableName = TableModel.getTableName(dialect, entityMeta);

            String constraintName = dialect.getNamingConvention().sqlForeignKeyName(this.tableName, member.sqlName(), refSqlTableName);
            if (!tableMetadata.hasForeignKey(constraintName)) {
                SQLUtils.execute(persistenceContext.getConnection(), TableDDL.sqlCreateForeignKey(dialect, this, this.getTableName(), member.sqlName(),
                        refSqlTableName, mappings.getConfiguration().allowForeignKeyDeferrable()));
            }

        }

        for (MemberCollectionOperationsMeta member : entityOperationsMeta.getAutogeneratedCollectionMembers()) {
            TableMetadata memberTableMetadata = TableMetadata.getTableMetadata(persistenceContext, mappings.getConfiguration(), member.sqlName());
            memberTableMetadata.readForeignKeys(persistenceContext);
            {
                String constraintName = dialect.getNamingConvention().sqlForeignKeyName(member.sqlName(), member.sqlOwnerName(), tableName);
                if (!memberTableMetadata.hasForeignKey(constraintName)) {
                    SQLUtils.execute(persistenceContext.getConnection(), TableDDL.sqlCreateForeignKey(dialect, this, member.sqlName(), member.sqlOwnerName(),
                            tableName, mappings.getConfiguration().allowForeignKeyDeferrable()));
                }
            }

            if (member.getMemberMeta().getObjectClassType() != ObjectClassType.PrimitiveSet) {
                @SuppressWarnings("unchecked")
                Class<? extends IEntity> entityClass = (Class<IEntity>) member.getMemberMeta().getValueClass();
                if (entityClass.getAnnotation(AbstractEntity.class) == null) {
                    String refSqlTableName = TableModel.getTableName(dialect, EntityFactory.getEntityMeta(entityClass));
                    String constraintName = dialect.getNamingConvention().sqlForeignKeyName(member.sqlName(), member.sqlValueName(), refSqlTableName);
                    if (!memberTableMetadata.hasForeignKey(constraintName)) {
                        SQLUtils.execute(persistenceContext.getConnection(), TableDDL.sqlCreateForeignKey(dialect, this, member.sqlName(),
                                member.sqlValueName(), refSqlTableName, mappings.getConfiguration().allowForeignKeyDeferrable()));
                    }
                }
            }
        }
    }

    public EntityMeta entityMeta() {
        return entityMeta;
    }

    public PrimaryKeyStrategy getPrimaryKeyStrategy() {
        return primaryKeyStrategy;
    }

    public EntityOperationsMeta operationsMeta() {
        return entityOperationsMeta;
    }

    public static boolean isTableExists(PersistenceContext persistenceContext, EntityMeta entityMeta) throws SQLException {
        return (TableMetadata.isTableExists(persistenceContext, getTableName(persistenceContext.getDialect(), entityMeta)));
    }

    public void dropTable(PersistenceContext persistenceContext) throws SQLException {
        List<String> sqls = new Vector<String>();
        for (MemberOperationsMeta member : entityOperationsMeta.getAutogeneratedCollectionMembers()) {
            TableMetadata memberTableMetadata = TableMetadata.getTableMetadata(persistenceContext, mappings.getConfiguration(), member.sqlName());
            if (memberTableMetadata != null) {
                memberTableMetadata.readReferenceForeignKeys(persistenceContext);
                for (String fk : memberTableMetadata.getForeignKeyNames()) {
                    sqls.add(persistenceContext.getDialect().sqlDropForeignKey(member.sqlName(), fk));
                }
                for (Map.Entry<String, String> ref : memberTableMetadata.getForeignKeysReference().entrySet()) {
                    sqls.add(persistenceContext.getDialect().sqlDropForeignKey(ref.getValue(), ref.getKey()));
                }
                sqls.add("DROP TABLE " + member.sqlName());
            }
        }
        SQLUtils.execute(persistenceContext.getConnection(), sqls);
        sqls.clear();
        TableMetadata memberTableMetadata = TableMetadata.getTableMetadata(persistenceContext, mappings.getConfiguration(), tableName);
        if (memberTableMetadata != null) {
            memberTableMetadata.readReferenceForeignKeys(persistenceContext);
            for (String fk : memberTableMetadata.getForeignKeyNames()) {
                sqls.add(persistenceContext.getDialect().sqlDropForeignKey(tableName, fk));
            }
            for (Map.Entry<String, String> ref : memberTableMetadata.getForeignKeysReference().entrySet()) {
                sqls.add(persistenceContext.getDialect().sqlDropForeignKey(ref.getValue(), ref.getKey()));
            }
        }
        sqls.add("DROP TABLE " + tableName);
        SQLUtils.execute(persistenceContext.getConnection(), sqls);
    }

    public int dropForeignKeys(PersistenceContext persistenceContext) throws SQLException {
        int count = 0;
        List<String> sqls = new Vector<String>();
        for (MemberOperationsMeta member : entityOperationsMeta.getAutogeneratedCollectionMembers()) {
            TableMetadata memberTableMetadata = TableMetadata.getTableMetadata(persistenceContext, mappings.getConfiguration(), member.sqlName());
            if (memberTableMetadata != null) {
                memberTableMetadata.readReferenceForeignKeys(persistenceContext);
                for (String fk : memberTableMetadata.getForeignKeyNames()) {
                    sqls.add(persistenceContext.getDialect().sqlDropForeignKey(member.sqlName(), fk));
                    count++;
                }
                for (Map.Entry<String, String> ref : memberTableMetadata.getForeignKeysReference().entrySet()) {
                    sqls.add(persistenceContext.getDialect().sqlDropForeignKey(ref.getValue(), ref.getKey()));
                    count++;
                }
            }
        }
        SQLUtils.execute(persistenceContext.getConnection(), sqls);
        sqls.clear();
        TableMetadata memberTableMetadata = TableMetadata.getTableMetadata(persistenceContext, mappings.getConfiguration(), tableName);
        if (memberTableMetadata != null) {
            memberTableMetadata.readReferenceForeignKeys(persistenceContext);
            for (String fk : memberTableMetadata.getForeignKeyNames()) {
                sqls.add(persistenceContext.getDialect().sqlDropForeignKey(tableName, fk));
                count++;
            }
            for (Map.Entry<String, String> ref : memberTableMetadata.getForeignKeysReference().entrySet()) {
                sqls.add(persistenceContext.getDialect().sqlDropForeignKey(ref.getValue(), ref.getKey()));
                count++;
            }
        }
        SQLUtils.execute(persistenceContext.getConnection(), sqls);
        return count;
    }

    public void debugErrors(PersistenceContext persistenceContext, Throwable throwable) {
        if (throwable instanceof SQLNonTransientConnectionException) {
            PersistenceContext.debugOpenSessions();
        }
    }

    private String sqlInsert() {
        if (sqlInsert == null) {
            boolean returnAutoGeneratedKeys = (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS);

            StringBuilder sql = new StringBuilder();
            sql.append(" (");
            int numberOfParams = 0;

            if (classModel != ModelType.regular) {
                if (numberOfParams > 0) {
                    sql.append(", ");
                }
                sql.append(dialect.sqlDiscriminatorColumnName());
                numberOfParams++;
            }

            for (MemberOperationsMeta member : entityOperationsMeta.getColumnMembers()) {
                for (String name : member.getValueAdapter().getColumnNames(member.sqlName())) {
                    if (numberOfParams != 0) {
                        sql.append(", ");
                    }
                    sql.append(name);
                    numberOfParams++;
                }
            }

            for (MemberOperationsMeta member : entityOperationsMeta.getIndexMembers()) {
                if (numberOfParams > 0) {
                    sql.append(", ");
                }
                sql.append(member.sqlName());
                numberOfParams++;
            }
            if (dialect.isMultitenantSharedSchema()) {
                if (numberOfParams > 0) {
                    sql.append(", ");
                }
                sql.append(dialect.getNamingConvention().sqlNameSpaceColumnName());
                numberOfParams++;
            }
            if (!returnAutoGeneratedKeys) {
                if (numberOfParams > 0) {
                    sql.append(", ");
                }
                sql.append(dialect.getNamingConvention().sqlIdColumnName());
                numberOfParams++;
            } else if (dialect.isSequencesBaseIdentity()) {
                if (numberOfParams > 0) {
                    sql.append(", ");
                }
                sql.append(dialect.getNamingConvention().sqlIdColumnName());
            }
            sql.append(") VALUES (");
            for (int i = 0; i < numberOfParams; i++) {
                if (i != 0) {
                    sql.append(", ");
                }
                sql.append("?");
            }
            if (returnAutoGeneratedKeys && dialect.isSequencesBaseIdentity()) {
                if (numberOfParams != 0) {
                    sql.append(", ");
                }
                String sequenceName = dialect.getNamingConvention().sqlTableSequenceName(entityMeta.getPersistenceName());
                if (mappings.sharedSequencesSchema() != null) {
                    sequenceName = mappings.sharedSequencesSchema() + "." + sequenceName;
                }
                sql.append(dialect.getSequenceNextValSql(sequenceName));
            }
            sql.append(")");
            sqlInsert = sql.toString();
        }
        return sqlInsert;
    }

    private String sqlUpdate() {
        if (sqlUpdate == null) {
            StringBuilder sql = new StringBuilder();
            sql.append(" SET ");
            boolean first = true;

            for (MemberOperationsMeta member : entityOperationsMeta.getColumnMembers()) {
                for (String name : member.getValueAdapter().getColumnNames(member.sqlName())) {
                    if (first) {
                        first = false;
                    } else {
                        sql.append(", ");
                    }
                    sql.append(name).append(" = ? ");
                }
            }
            for (MemberOperationsMeta member : entityOperationsMeta.getIndexMembers()) {
                sql.append(',').append(member.sqlName()).append(" = ? ");
            }
            sql.append(" WHERE ").append(dialect.getNamingConvention().sqlIdColumnName()).append(" = ? ");
            if (dialect.isMultitenantSharedSchema()) {
                sql.append(" AND ").append(dialect.getNamingConvention().sqlNameSpaceColumnName()).append(" = ? ");
            }
            if (classModel != ModelType.regular) {
                sql.append(" AND ").append(dialect.sqlDiscriminatorColumnName()).append(" = ? ");
            }
            sqlUpdate = sql.toString();
        }
        return sqlUpdate;
    }

    private String sqlUpdateBulk(String alias, IEntity entityTemplate) {
        StringBuilder sql = new StringBuilder();
        sql.append(" SET ");
        boolean first = true;
        for (MemberOperationsMeta member : entityOperationsMeta.getColumnMembers()) {
            if (!member.containsMemberValue(entityTemplate)) {
                continue;
            }
            for (String name : member.getValueAdapter().getColumnNames(member.sqlName())) {
                if (first) {
                    first = false;
                } else {
                    sql.append(", ");
                }
                sql.append(name).append(" = ? ");
            }
        }
        return sql.toString();
    }

    private void bindParameter(PreparedStatement stmt, int parameterIndex, Class<?> valueClass, Object value, MemberMeta memberMeta) throws SQLException {
        if (value == null) {
            stmt.setNull(parameterIndex, dialect.getTargetSqlType(valueClass));
        } else {
            stmt.setObject(parameterIndex, encodeValue(valueClass, value), dialect.getTargetSqlType(valueClass));
        }
    }

    private int bindPersistParameters(int parameterIndex, PersistenceContext persistenceContext, PreparedStatement stmt, IEntity entity) throws SQLException {
        for (MemberOperationsMeta member : entityOperationsMeta.getColumnMembers()) {
            if (member.getMemberMeta().isEntity()) {
                IEntity childEntity = (IEntity) member.getMember(entity);
                if ((childEntity.getPrimaryKey() == null) && childEntity.hasValues()) {
                    log.error("Saving non persisted reference {}\n{}\n", childEntity, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
                    throw new Error("Saving non persisted reference " + childEntity.getDebugExceptionInfoString());
                }
                if (member.isOwnerColumn() && (!childEntity.hasValues()) && member.getMemberMeta().getAnnotation(NotNull.class) != null) {
                    log.error("Saving empty owner reference {}\n{}\n", childEntity, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
                    throw new Error("Trying to save child entity with undefined owner; " + childEntity.getDebugExceptionInfoString());
                }
                parameterIndex += member.getValueAdapter().bindValue(persistenceContext, stmt, parameterIndex, childEntity);
            } else {
                parameterIndex += member.getValueAdapter().bindValue(persistenceContext, stmt, parameterIndex, member.getPersistMemberValue(entity));
            }
        }
        for (MemberOperationsMeta member : entityOperationsMeta.getIndexMembers()) {
            bindParameter(stmt, parameterIndex, member.getIndexValueClass(), member.getIndexedValue(entity), null);
            parameterIndex++;
        }
        return parameterIndex;
    }

    private int bindPersistParametersBulk(int parameterIndex, PersistenceContext persistenceContext, PreparedStatement stmt, IEntity entityTemplate)
            throws SQLException {
        for (MemberOperationsMeta member : entityOperationsMeta.getColumnMembers()) {
            if (!member.containsMemberValue(entityTemplate)) {
                continue;
            } else if (member.getMemberMeta().isEntity()) {
                IEntity childEntity = (IEntity) member.getMember(entityTemplate);
                if ((childEntity.getPrimaryKey() == null) && childEntity.hasValues()) {
                    log.error("Saving non persisted reference {}\n{}\n", childEntity, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
                    throw new Error("Saving non persisted reference " + childEntity.getDebugExceptionInfoString());
                }
                if (member.isOwnerColumn() && (!childEntity.hasValues()) && member.getMemberMeta().getAnnotation(NotNull.class) != null) {
                    log.error("Saving empty owner reference {}\n{}\n", childEntity, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
                    throw new Error("Trying to save child entity with undefined owner; " + childEntity.getDebugExceptionInfoString());
                }
                parameterIndex += member.getValueAdapter().bindValue(persistenceContext, stmt, parameterIndex, childEntity);
            } else {
                parameterIndex += member.getValueAdapter().bindValue(persistenceContext, stmt, parameterIndex, member.getPersistMemberValue(entityTemplate));
            }
        }
//TODO        
//        for (MemberOperationsMeta member : entityOperationsMeta.getIndexMembers()) {
//            bindParameter(stmt, parameterIndex, member.getIndexValueClass(), member.getIndexedValue(entityTemplate), null);
//            parameterIndex++;
//        }
        return parameterIndex;
    }

    public void insert(PersistenceContext persistenceContext, IEntity entity) {
        PreparedStatement stmt = null;
        StringBuilder sql = new StringBuilder();
        try {
            sql.append("INSERT INTO ");
            sql.append(getFullTableName());
            sql.append(sqlInsert());

            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            if (dialect.isSequencesBaseIdentity()) {
                stmt = persistenceContext.getConnection().prepareStatement(sql.toString(), new String[] { dialect.getNamingConvention().sqlIdColumnName() });
            } else {
                stmt = persistenceContext.getConnection().prepareStatement(sql.toString(), autoGeneratedKeys);
            }
            int parameterIndex = 1;
            if (classModel != ModelType.regular) {
                DiscriminatorValue discriminator = entity.getValueClass().getAnnotation(DiscriminatorValue.class);
                assert (discriminator != null) : "Can't persist Abstract " + entity.getValueClass();
                stmt.setString(parameterIndex, discriminator.value());
                parameterIndex++;
            }
            parameterIndex = bindPersistParameters(parameterIndex, persistenceContext, stmt, entity);
            if (dialect.isMultitenantSharedSchema()) {
                stmt.setString(parameterIndex, NamespaceManager.getNamespace());
                parameterIndex++;
            }
            if (autoGeneratedKeys == Statement.NO_GENERATED_KEYS) {
                if (entity.getPrimaryKey() == null) {
                    throw new Error("Can't persist Entity without assigned PK");
                }
                stmt.setLong(parameterIndex, entity.getPrimaryKey().asLong());
            }
            persistenceContext.setUncommittedChanges();
            stmt.executeUpdate();
            if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS) {
                ResultSet keys = stmt.getGeneratedKeys();
                try {
                    if (!keys.next()) {
                        throw new RuntimeException("Generated Key was not returned");
                    }
                    entity.setPrimaryKey(new Key(keys.getLong(1)));
                } finally {
                    SQLUtils.closeQuietly(keys);
                }
            }
            if (PersistenceTrace.trace) {
                log.info(Trace.id() + "saved {} [{}] ", this.getTableName(), entity.getPrimaryKey());
            }
        } catch (SQLException e) {
            log.error("{} SQL {}", tableName, sql);
            log.error("{} SQL insert error", tableName, e);
            debugErrors(persistenceContext, e);
            if (dialect.isUniqueConstraintException(e)) {
                throw new UniqueConstraintUserRuntimeException(i18n.tr("Unable to create \"{0}\", duplicate \"{1}\" exists", entityMeta().getCaption(),
                        getUniqueConstraintFieldName()), EntityFactory.getEntityPrototype(entity.getValueClass()));
            } else {
                throw new RuntimeException(e);
            }
        } finally {
            SQLUtils.closeQuietly(stmt);
        }
    }

    public boolean update(PersistenceContext persistenceContext, IEntity entity) {
        PreparedStatement stmt = null;
        StringBuilder sql = new StringBuilder();
        try {
            sql.append("UPDATE  ");
            sql.append(getFullTableName());
            sql.append(sqlUpdate());

            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            stmt = persistenceContext.getConnection().prepareStatement(sql.toString());
            // Just in case, used for pooled connections
            stmt.setMaxRows(1);
            int parameterIndex = 1;
            parameterIndex = bindPersistParameters(parameterIndex, persistenceContext, stmt, entity);
            stmt.setLong(parameterIndex, entity.getPrimaryKey().asLong());
            if (dialect.isMultitenantSharedSchema()) {
                parameterIndex++;
                stmt.setString(parameterIndex, NamespaceManager.getNamespace());
            }
            if (classModel != ModelType.regular) {
                parameterIndex++;
                DiscriminatorValue discriminator = entity.getValueClass().getAnnotation(DiscriminatorValue.class);
                stmt.setString(parameterIndex, discriminator.value());
            }
            persistenceContext.setUncommittedChanges();
            boolean updated = (stmt.executeUpdate() == 1);
            if (PersistenceTrace.traceWarnings) {
                SQLUtils.logAndClearWarnings(persistenceContext.getConnection());
            }
            return updated;
        } catch (SQLException e) {
            log.error("{} SQL {}", tableName, sql);
            log.error("{} SQL update error", tableName, e);
            debugErrors(persistenceContext, e);
            if (dialect.isUniqueConstraintException(e)) {
                throw new UniqueConstraintUserRuntimeException(i18n.tr("Unable to update \"{0}\", duplicate \"{1}\" exists", entityMeta().getCaption(),
                        getUniqueConstraintFieldName()), EntityFactory.getEntityPrototype(entity.getValueClass()));
            } else {
                throw new RuntimeException(e);
            }
        } finally {
            SQLUtils.closeQuietly(stmt);
        }
    }

    public <T extends IEntity> int updateBulk(PersistenceContext persistenceContext, EntityQueryCriteria<T> criteria, T entityTemplate) {
        PreparedStatement stmt = null;
        StringBuilder sql = new StringBuilder();
        try {
            QueryBuilder<T> qb = new QueryBuilder<T>(persistenceContext, mappings, "m1", entityOperationsMeta, criteria);
            sql.append("UPDATE ").append(qb.getUpdateSQL(getFullTableName(), sqlUpdateBulk("m1", entityTemplate)));
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            stmt = persistenceContext.getConnection().prepareStatement(sql.toString());
            int parameterIndex = 1;
            parameterIndex = bindPersistParametersBulk(parameterIndex, persistenceContext, stmt, entityTemplate);
            parameterIndex = qb.bindParameters(parameterIndex, persistenceContext, stmt);
            persistenceContext.setUncommittedChanges();
            int updated = stmt.executeUpdate();
            if (PersistenceTrace.traceWarnings) {
                SQLUtils.logAndClearWarnings(persistenceContext.getConnection());
            }
            return updated;
        } catch (SQLException e) {
            log.error("{} SQL {}", tableName, sql);
            log.error("{} SQL update error", tableName, e);
            debugErrors(persistenceContext, e);
            if (dialect.isUniqueConstraintException(e)) {
                throw new UniqueConstraintUserRuntimeException(i18n.tr("Unable to update \"{0}\", duplicate \"{1}\" exists", entityMeta().getCaption(),
                        getUniqueConstraintFieldName()), EntityFactory.getEntityPrototype(entityTemplate.getValueClass()));
            } else {
                throw new RuntimeException(e);
            }
        } finally {
            SQLUtils.closeQuietly(stmt);
        }
    }

    private String getUniqueConstraintFieldName() {
        StringBuilder b = new StringBuilder();
        for (MemberOperationsMeta member : operationsMeta().getColumnMembers()) {
            if (member.getMemberMeta().isIndexed() && member.getMemberMeta().getAnnotation(Indexed.class).uniqueConstraint()) {
                if (b.length() > 0) {
                    b.append(", ");
                }
                b.append(member.getMemberMeta().getCaption());
            }
        }
        if (b.length() == 0) {
            b.append(i18n.tr("Record"));
        }
        return b.toString();
    }

    static Object encodeValue(Class<?> valueClass, Object value) {
        if (valueClass.isEnum()) {
            return ((Enum<?>) value).name();
        } else if (valueClass.equals(java.util.Date.class)) {
            Calendar c = new GregorianCalendar();
            c.setTime((java.util.Date) value);
            // DB does not store Milliseconds
            c.set(Calendar.MILLISECOND, 0);
            return new java.sql.Timestamp(c.getTimeInMillis());
        } else {
            return value;
        }
    }

    private TableModel retrieveDiscriminator(PersistenceContext persistenceContext, ResultSet rs, IEntity entity) throws SQLException {
        if (classModel != ModelType.regular) {
            String discriminator = rs.getString(dialect.sqlDiscriminatorColumnName());
            if (classModel == ModelType.superclass) {
                Class<? extends IEntity> subclass = entityOperationsMeta.impClasses.get(discriminator);
                TableModel subclassModel = mappings.getTableModel(persistenceContext, subclass);

                IEntity subclassValue = EntityFactory.create(subclass);
                subclassValue.setPrimaryKey(entity.getPrimaryKey());
                entity.set(subclassValue);
                return subclassModel;
            } else {
                //TODO assert discriminator value
            }
        }
        return this;
    }

    private void retrieveValues(ResultSet rs, IEntity entity) throws SQLException {
        entity.setValuePopulated();
        for (MemberOperationsMeta member : entityOperationsMeta.getColumnMembers()) {
            Serializable value = member.getValueAdapter().retrieveValue(rs, member.sqlName());
            if (value != null) {
                if (member.getMemberMeta().isEntity()) {
                    IEntity valueEntity = (IEntity) value;
                    IEntity memberValue = (IEntity) member.getMember(entity);
                    if (member.isOwnerColumn()) {
                        // Special handling for recursive retrieve of Owner
                        if ((entity.getOwner() != null) && (entity.getMeta() != null) && entity.getMeta().isOwnedRelationships()) {
                            // verify graph integrity
                            if (entity.getOwner().getPrimaryKey().asLong() != valueEntity.getPrimaryKey().asLong()) {
                                throw new RuntimeException("Unexpected owner " + member.getMemberPath() + " '" + valueEntity.getDebugExceptionInfoString()
                                        + "' != '" + entity.getOwner().getDebugExceptionInfoString() + "' in entity '" + entity.getDebugExceptionInfoString()
                                        + "'");
                            }
                        } else {
                            memberValue.set(valueEntity);
                        }
                    } else {
                        memberValue.set(valueEntity);
                    }
                } else {
                    member.setMemberValue(entity, value);
                }
            }
        }
    }

    private void retrieveExternal(PersistenceContext persistenceContext, IEntity entity, AttachLevel attachLevel) {
        for (MemberCollectionOperationsMeta member : entityOperationsMeta.getCollectionMembers()) {
            if (member.getMemberMeta().getAttachLevel() != AttachLevel.Detached) {
                TableModelCollections.retrieve(persistenceContext, entity, member);
            } else {
                member.getMember(entity).setAttachLevel(AttachLevel.Detached);
            }
        }
        for (MemberExternalOperationsMeta member : entityOperationsMeta.getExternalMembers()) {
            // Do not retrieve Owner, since already retrieved
            if ((entity.getOwner() != null) && (member.getMemberMeta().isOwner())
                    && entity.getOwner().isInstanceOf((Class<? extends IEntity>) member.getMemberMeta().getValueClass())) {
                continue;
            }
            if (member.getMemberMeta().getAttachLevel() == AttachLevel.Detached) {
                member.getMember(entity).setAttachLevel(AttachLevel.Detached);
                continue;
            }
            if (attachLevel == AttachLevel.ToStringMembers) {
                if (member.getMemberMeta().isToStringMember()) {
                    TableModelExternal.retrieve(persistenceContext, entity, member);
                } else {
                    member.getMember(entity).setAttachLevel(AttachLevel.Detached);
                }
            } else {
                TableModelExternal.retrieve(persistenceContext, entity, member);
            }
        }

        for (MemberOperationsMeta member : entityOperationsMeta.getVersionInfoMembers()) {
            TableModleVersioned.retrieveVersion(persistenceContext, mappings, entity, member);
        }
    }

    public boolean isExternalMember(IEntity entity, IEntity entityMember) {
        return entityOperationsMeta.getMember(new Path(entity.getValueClass(), entityMember.getFieldName()).toString()) instanceof MemberExternalOperationsMeta;
    }

    public void retrieveMember(PersistenceContext persistenceContext, IEntity entity, IEntity entityMember) {
        MemberOperationsMeta member = entityOperationsMeta.getMember(new Path(entity.getValueClass(), entityMember.getFieldName()).toString());
        assert (member != null) : "Member " + entityMember.getFieldName() + " not found";
        TableModelExternal.retrieve(persistenceContext, entity, (MemberExternalOperationsMeta) member);
    }

    public void retrieveMember(PersistenceContext persistenceContext, IEntity entity, ICollection<?, ?> collectionMember) {
        MemberOperationsMeta member = entityOperationsMeta.getMember(new Path(entity.getValueClass(), collectionMember.getFieldName()).toString());
        assert (member != null) : "Member " + collectionMember.getFieldName() + " not found";
        TableModelCollections.retrieve(persistenceContext, entity, (MemberCollectionOperationsMeta) member);
    }

    public boolean retrieve(PersistenceContext persistenceContext, Key primaryKey, IEntity entity, AttachLevel attachLevel, boolean forUpdate) {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        StringBuilder sql = new StringBuilder();
        try {
            sql.append("SELECT * FROM ").append(getFullTableName());
            sql.append(" WHERE ").append(dialect.getNamingConvention().sqlIdColumnName()).append(" = ?");
            if (dialect.isMultitenantSharedSchema()) {
                sql.append(" AND ").append(dialect.getNamingConvention().sqlNameSpaceColumnName()).append(" = ?");
            }
            if (forUpdate) {
                sql.append(" FOR UPDATE");
            }
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            stmt = persistenceContext.getConnection().prepareStatement(sql.toString());
            // Just in case, used for pooled connections
            stmt.setMaxRows(1);

            stmt.setLong(1, primaryKey.asLong());
            if (dialect.isMultitenantSharedSchema()) {
                stmt.setString(2, NamespaceManager.getNamespace());
            }

            rs = stmt.executeQuery();
            if (!rs.next()) {
                return false;
            } else {
                Key key = new Key(rs.getLong(dialect.getNamingConvention().sqlIdColumnName()));
                // Ignore version in comparison
                if (primaryKey.asLong() != key.asLong()) {
                    throw new RuntimeException();
                }
                if ((dialect.isMultitenantSharedSchema())
                        && !rs.getString(dialect.getNamingConvention().sqlNameSpaceColumnName()).equals(NamespaceManager.getNamespace())) {
                    throw new RuntimeException("namespace access error");
                }
                // Preserve version when retrieving key
                entity.setPrimaryKey(primaryKey);
                TableModel subclassModel = retrieveDiscriminator(persistenceContext, rs, entity);
                if (attachLevel.ordinal() > AttachLevel.IdOnly.ordinal()) {
                    subclassModel.retrieveValues(rs, entity.cast());
                    subclassModel.retrieveExternal(persistenceContext, entity.cast(), attachLevel);
                }
                return true;
            }
        } catch (SQLException e) {
            log.error("{} SQL: {}", tableName, sql);
            log.error("{} SQL select error", tableName, e);
            debugErrors(persistenceContext, e);
            throw new RuntimeException(e);
        } finally {
            SQLUtils.closeQuietly(rs);
            SQLUtils.closeQuietly(stmt);
        }
    }

    public <T extends IEntity> List<T> query(PersistenceContext persistenceContext, EntityQueryCriteria<T> criteria, int limit, AttachLevel attachLevel) {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        String sql = null;
        try {
            QueryBuilder<T> qb = new QueryBuilder<T>(persistenceContext, mappings, "m1", entityOperationsMeta, criteria);
            sql = "SELECT " + (qb.addDistinct() ? "DISTINCT" : "") + " m1.*" + qb.getColumnsSQL() + " FROM " + qb.getSQL(getFullTableName());
            //log.info("query {}", sql);
            int offset = 0;
            boolean addLimit = false;
            if (criteria instanceof EntityListCriteria) {
                EntityListCriteria<T> c = (EntityListCriteria<T>) criteria;
                if (c.getPageSize() > 0) {
                    offset = c.getPageSize() * c.getPageNumber();
                    if (limit > 0) {
                        limit = Math.min(limit, c.getPageSize());
                    } else {
                        limit = c.getPageSize();
                    }
                    addLimit = true;
                    sql = dialect.applyLimitCriteria(sql);
                }
            }
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            stmt = persistenceContext.getConnection().prepareStatement(sql);
            if (limit > 0) {
                stmt.setMaxRows(limit);
            } else {
                // zero means there is no limit, Need for pooled connections
                stmt.setMaxRows(0);
            }
            int parameterIndex = qb.bindParameters(persistenceContext, stmt);
            if (addLimit) {
                switch (dialect.limitCriteriaType()) {
                case AbsolutCriteria:
                    stmt.setInt(parameterIndex, offset + limit);
                    parameterIndex++;
                    break;
                case Standard:
                    stmt.setInt(parameterIndex, limit);
                    parameterIndex++;
                    break;
                default:
                    break;
                }
                stmt.setInt(parameterIndex, offset);
            }
            rs = stmt.executeQuery();

            List<T> rc = new Vector<T>();

            PrimaryKeyCriteriaHelper primaryKeyCriteriaHelper = new PrimaryKeyCriteriaHelper(criteria);

            while (rs.next()) {
                @SuppressWarnings("unchecked")
                T entity = (T) EntityFactory.create(entityMeta.getEntityClass());
                entity.setPrimaryKey(primaryKeyCriteriaHelper.getRetrievedKey(rs.getLong(dialect.getNamingConvention().sqlIdColumnName())));
                if ((dialect.isMultitenantSharedSchema())
                        && !rs.getString(dialect.getNamingConvention().sqlNameSpaceColumnName()).equals(NamespaceManager.getNamespace())) {
                    throw new RuntimeException("namespace access error");
                }
                TableModel subclassModel = retrieveDiscriminator(persistenceContext, rs, entity);
                if (attachLevel.ordinal() > AttachLevel.IdOnly.ordinal()) {
                    subclassModel.retrieveValues(rs, entity.cast());
                    subclassModel.retrieveExternal(persistenceContext, entity.cast(), attachLevel);
                }
                rc.add(entity);
            }
            return rc;
        } catch (SQLException e) {
            log.error("{} SQL: {}", tableName, sql);
            log.error("{} SQL select error", tableName, e);
            debugErrors(persistenceContext, e);
            throw new RuntimeException(e);
        } finally {
            SQLUtils.closeQuietly(rs);
            SQLUtils.closeQuietly(stmt);
        }
    }

    public <T extends IEntity> ResultSetIterator<T> queryIterable(final PersistenceContext persistenceContext, EntityQueryCriteria<T> criteria,
            final AttachLevel attachLevel) {
        String sql = null;
        QueryBuilder<T> qb = new QueryBuilder<T>(persistenceContext, mappings, "m1", entityOperationsMeta, criteria);
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            sql = "SELECT " + (qb.addDistinct() ? "DISTINCT" : "") + " m1.*" + qb.getColumnsSQL() + " FROM " + qb.getSQL(getFullTableName());
            //log.info("query {}", sql);
            int limit = -1;
            int offset = 0;
            if (criteria instanceof EntityListCriteria) {
                EntityListCriteria<T> c = (EntityListCriteria<T>) criteria;
                if (c.getPageSize() > 0) {
                    offset = c.getPageSize() * c.getPageNumber();
                    limit = c.getPageSize() + 1;
                    sql = dialect.applyLimitCriteria(sql);
                }
            }
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            stmt = persistenceContext.getConnection().prepareStatement(sql);
            if (limit > 0) {
                stmt.setMaxRows(limit);
            } else {
                // zero means there is no limit, Need for pooled connections
                stmt.setMaxRows(0);
            }
            int parameterIndex = qb.bindParameters(persistenceContext, stmt);
            if (limit > 0) {
                switch (dialect.limitCriteriaType()) {
                case AbsolutCriteria:
                    stmt.setInt(parameterIndex, offset + limit);
                    parameterIndex++;
                    break;
                case Standard:
                    stmt.setInt(parameterIndex, limit);
                    parameterIndex++;
                    break;
                default:
                    break;
                }
                stmt.setInt(parameterIndex, offset);
            }

            rs = stmt.executeQuery();
        } catch (SQLException e) {
            SQLUtils.closeQuietly(stmt);
            log.error("{} SQL: {}", tableName, sql);
            log.error("{} SQL select error", tableName, e);
            debugErrors(persistenceContext, e);
            throw new RuntimeException(e);
        }

        final PrimaryKeyCriteriaHelper primaryKeyCriteriaHelper = new PrimaryKeyCriteriaHelper(criteria);

        return new ResultSetIterator<T>(stmt, rs) {

            @Override
            protected T retrieve() {
                @SuppressWarnings("unchecked")
                T entity = (T) EntityFactory.create(entityMeta.getEntityClass());
                TableModel subclassModel;
                try {
                    entity.setPrimaryKey(primaryKeyCriteriaHelper.getRetrievedKey(rs.getLong(dialect.getNamingConvention().sqlIdColumnName())));
                    subclassModel = retrieveDiscriminator(persistenceContext, rs, entity);
                    if (attachLevel.ordinal() > AttachLevel.IdOnly.ordinal()) {
                        subclassModel.retrieveValues(rs, entity.cast());
                    }
                } catch (SQLException e) {
                    log.error("{} SQL select error", tableName, e);
                    throw new RuntimeException(e);
                }
                if (attachLevel.ordinal() > AttachLevel.IdOnly.ordinal()) {
                    subclassModel.retrieveExternal(persistenceContext, entity.cast(), attachLevel);
                }
                return entity;
            }
        };

    }

    public boolean exists(PersistenceContext persistenceContext, Key primaryKey) {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        StringBuilder sql = new StringBuilder();
        try {
            sql.append("SELECT ").append(dialect.getNamingConvention().sqlIdColumnName());
            sql.append(" FROM ").append(getFullTableName()).append(" WHERE ").append(dialect.getNamingConvention().sqlIdColumnName()).append(" = ?");
            if (dialect.isMultitenantSharedSchema()) {
                sql.append(" AND ").append(dialect.getNamingConvention().sqlNameSpaceColumnName()).append(" = ?");
            }
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            stmt = persistenceContext.getConnection().prepareStatement(sql.toString());
            // Just in case, used for pooled connections
            stmt.setMaxRows(1);

            stmt.setLong(1, primaryKey.asLong());
            if (dialect.isMultitenantSharedSchema()) {
                stmt.setString(2, NamespaceManager.getNamespace());
            }

            rs = stmt.executeQuery();
            if (!rs.next()) {
                return false;
            } else {
                Key key = new Key(rs.getLong(dialect.getNamingConvention().sqlIdColumnName()));
                if (!primaryKey.equals(key)) {
                    throw new RuntimeException();
                }
                return true;
            }
        } catch (SQLException e) {
            log.error("{} SQL: {}", tableName, sql);
            log.error("{} SQL select error", tableName, e);
            debugErrors(persistenceContext, e);
            throw new RuntimeException(e);
        } finally {
            SQLUtils.closeQuietly(rs);
            SQLUtils.closeQuietly(stmt);
        }
    }

    public <T extends IEntity> List<Key> queryKeys(PersistenceContext persistenceContext, EntityQueryCriteria<T> criteria, int limit) {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        String sql = null;
        try {
            QueryBuilder<T> qb = new QueryBuilder<T>(persistenceContext, mappings, "m1", entityOperationsMeta, criteria);
            sql = "SELECT " + (qb.addDistinct() ? "DISTINCT" : "") + " m1." + dialect.getNamingConvention().sqlIdColumnName() + qb.getColumnsSQL() + " FROM "
                    + qb.getSQL(getFullTableName());
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            stmt = persistenceContext.getConnection().prepareStatement(sql);
            if (limit > 0) {
                stmt.setMaxRows(limit);
            } else {
                // zero means there is no limit, Need for pooled connections
                stmt.setMaxRows(0);
            }
            qb.bindParameters(persistenceContext, stmt);

            rs = stmt.executeQuery();

            List<Key> rc = new Vector<Key>();
            while (rs.next()) {
                rc.add(new Key(rs.getLong(dialect.getNamingConvention().sqlIdColumnName())));
            }
            return rc;
        } catch (SQLException e) {
            log.error("{} SQL: {}", tableName, sql);
            log.error("{} SQL select error", tableName, e);
            debugErrors(persistenceContext, e);
            throw new RuntimeException(e);
        } finally {
            SQLUtils.closeQuietly(rs);
            SQLUtils.closeQuietly(stmt);
        }
    }

    public <T extends IEntity> ResultSetIterator<Key> queryKeysIterable(final PersistenceContext persistenceContext, EntityQueryCriteria<T> criteria) {
        String sql = null;
        QueryBuilder<T> qb = new QueryBuilder<T>(persistenceContext, mappings, "m1", entityOperationsMeta, criteria);
        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            sql = "SELECT " + (qb.addDistinct() ? "DISTINCT" : "") + " m1." + dialect.getNamingConvention().sqlIdColumnName() + qb.getColumnsSQL() + " FROM "
                    + qb.getSQL(getFullTableName());
            int limit = -1;
            int offset = 0;
            if (criteria instanceof EntityListCriteria) {
                EntityListCriteria<T> c = (EntityListCriteria<T>) criteria;
                if (c.getPageSize() > 0) {
                    offset = c.getPageSize() * c.getPageNumber();
                    limit = c.getPageSize() + 1;
                    sql = dialect.applyLimitCriteria(sql);
                }
            }
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            stmt = persistenceContext.getConnection().prepareStatement(sql);
            if (limit > 0) {
                stmt.setMaxRows(limit);
            } else {
                // zero means there is no limit, Need for pooled connections
                stmt.setMaxRows(0);
            }
            int parameterIndex = qb.bindParameters(persistenceContext, stmt);
            if (limit > 0) {
                switch (dialect.limitCriteriaType()) {
                case AbsolutCriteria:
                    stmt.setInt(parameterIndex, offset + limit);
                    parameterIndex++;
                    break;
                case Standard:
                    stmt.setInt(parameterIndex, limit);
                    parameterIndex++;
                    break;
                default:
                    break;
                }
                stmt.setInt(parameterIndex, offset);
            }

            rs = stmt.executeQuery();
        } catch (SQLException e) {
            SQLUtils.closeQuietly(stmt);
            log.error("{} SQL: {}", tableName, sql);
            log.error("{} SQL select error", tableName, e);
            debugErrors(persistenceContext, e);
            throw new RuntimeException(e);
        }

        return new ResultSetIterator<Key>(stmt, rs) {

            @Override
            protected Key retrieve() {
                try {
                    return new Key(rs.getLong("id"));
                } catch (SQLException e) {
                    log.error("{} SQL select error", tableName, e);
                    throw new RuntimeException(e);
                }
            }
        };

    }

    public <T extends IEntity> Object aggregate(PersistenceContext persistenceContext, EntityQueryCriteria<T> criteria, SQLAggregateFunctions func, String args) {
        PreparedStatement stmt = null;
        ResultSet rs = null;
        String sql = null;
        try {
            EntityQueryCriteria<T> criteriaNoSorts = criteria.iclone();
            criteriaNoSorts.setSorts(null);
            QueryBuilder<T> qb = new QueryBuilder<T>(persistenceContext, mappings, "m1", entityOperationsMeta, criteriaNoSorts);

            sql = "SELECT " + dialect.sqlFunction(qb, func, args) + " FROM " + qb.getSQL(getFullTableName());
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }

            stmt = persistenceContext.getConnection().prepareStatement(sql);
            // Just in case, used for pooled connections
            stmt.setMaxRows(1);
            qb.bindParameters(persistenceContext, stmt);

            rs = stmt.executeQuery();
            if (rs.next()) {
                return rs.getObject(1);
            } else {
                return null;
            }
        } catch (SQLException e) {
            log.error("{} SQL: {}", tableName, sql);
            log.error("{} SQL select error", tableName, e);
            throw new RuntimeException(e);
        } finally {
            SQLUtils.closeQuietly(rs);
            SQLUtils.closeQuietly(stmt);
        }
    }

    public boolean delete(PersistenceContext persistenceContext, Key primaryKey) {
        PreparedStatement stmt = null;
        StringBuilder sql = new StringBuilder();
        try {
            sql.append("DELETE FROM ").append(getFullTableName());
            sql.append(" WHERE ").append(dialect.getNamingConvention().sqlIdColumnName()).append(" = ?");
            if (dialect.isMultitenantSharedSchema()) {
                sql.append(" AND ").append(dialect.getNamingConvention().sqlNameSpaceColumnName()).append(" = ?");
            }
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            stmt = persistenceContext.getConnection().prepareStatement(sql.toString());
            stmt.setLong(1, primaryKey.asLong());
            if (dialect.isMultitenantSharedSchema()) {
                stmt.setString(2, NamespaceManager.getNamespace());
            }
            persistenceContext.setUncommittedChanges();
            int rc = stmt.executeUpdate();
            return rc >= 1;
        } catch (SQLException e) {
            log.error("{} SQL: {}", tableName, sql);
            log.error("{} SQL delete error", tableName, e);
            debugErrors(persistenceContext, e);
            if (dialect.isIntegrityConstraintException(e)) {
                throw new IntegrityConstraintUserRuntimeException(i18n.tr("Unable to delete \"{0}\". The record is referenced by another record.", entityMeta()
                        .getCaption()), EntityFactory.getEntityPrototype(entityMeta().getEntityClass()));
            } else {
                throw new RuntimeException(e);
            }
        } finally {
            SQLUtils.closeQuietly(stmt);
        }
    }

    public int delete(PersistenceContext persistenceContext, Iterable<Key> primaryKeys) {
        PreparedStatement stmt = null;
        StringBuilder sql = new StringBuilder();
        try {
            sql.append("DELETE FROM ").append(getFullTableName());
            sql.append(" WHERE ").append(dialect.getNamingConvention().sqlIdColumnName()).append(" = ?");
            if (dialect.isMultitenantSharedSchema()) {
                sql.append(" AND ").append(dialect.getNamingConvention().sqlNameSpaceColumnName()).append(" = ?");
            }
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            stmt = persistenceContext.getConnection().prepareStatement(sql.toString());
            int pkSize = 0;
            for (Key primaryKey : primaryKeys) {
                stmt.setLong(1, primaryKey.asLong());
                if (dialect.isMultitenantSharedSchema()) {
                    stmt.setString(2, NamespaceManager.getNamespace());
                }
                stmt.addBatch();
                pkSize++;
            }
            if (pkSize == 0) {
                return pkSize;
            }
            persistenceContext.setUncommittedChanges();
            int[] rc = stmt.executeBatch();
            int count = 0;
            for (int i = 0; i < rc.length; i++) {
                switch (rc[i]) {
                case Statement.EXECUTE_FAILED:
                    throw new RuntimeException("SQL delete failed");
                case Statement.SUCCESS_NO_INFO:
                    count++;
                    break;
                default:
                    count += rc[i];
                }
            }
            return count;
        } catch (SQLException e) {
            log.error("{} SQL: {}", tableName, sql);
            log.error("{} SQL delete error", tableName, e);
            debugErrors(persistenceContext, e);
            throw new RuntimeException(e);
        } finally {
            SQLUtils.closeQuietly(stmt);
        }
    }

    public void truncate(PersistenceContext persistenceContext) {
        PreparedStatement stmt = null;
        try {
            stmt = persistenceContext.getConnection().prepareStatement("TRUNCATE TABLE " + getFullTableName());
            stmt.execute();
        } catch (SQLException e) {
            log.error("{} SQL delete error", tableName, e);
            throw new RuntimeException(e);
        } finally {
            SQLUtils.closeQuietly(stmt);
        }

    }

    public <T extends IEntity> boolean insert(PersistenceContext persistenceContext, Iterable<T> entityIterable) {
        PreparedStatement stmt = null;
        int[] vals = null;
        StringBuilder sql = new StringBuilder();
        try {
            sql.append("INSERT INTO ");
            sql.append(getFullTableName());
            sql.append(sqlInsert());
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            stmt = persistenceContext.getConnection().prepareStatement(sql.toString(), autoGeneratedKeys);
            for (T entity : entityIterable) {
                int parameterIndex = 1;
                parameterIndex = bindPersistParameters(parameterIndex, persistenceContext, stmt, entity);
                if (autoGeneratedKeys == Statement.NO_GENERATED_KEYS) {
                    stmt.setLong(parameterIndex, entity.getPrimaryKey().asLong());
                    parameterIndex++;
                }
                if (dialect.isMultitenantSharedSchema()) {
                    stmt.setString(parameterIndex, NamespaceManager.getNamespace());
                    parameterIndex++;
                }
                stmt.addBatch();
            }
            persistenceContext.setUncommittedChanges();
            vals = stmt.executeBatch(); // INSERTs
            for (int i = 0; i < vals.length; i++) {
                if (vals[i] == 0) {
                    // not inserted ???
                }
            }

            if (autoGeneratedKeys == Statement.RETURN_GENERATED_KEYS) {
                ResultSet keys = null;
                try {
                    keys = stmt.getGeneratedKeys();
                    for (T entity : entityIterable) {
                        keys.next();
                        entity.setPrimaryKey(new Key(keys.getLong(1)));
                    }
                } catch (SQLException e) {
                    log.error("{} SQL {}", tableName, sqlInsert);
                    log.error("{} SQL PrimaryKey retrieval error", tableName, e);
                    throw new RuntimeException(e);
                } finally {
                    SQLUtils.closeQuietly(keys);
                }
            }

            return true; //good, we reached this without exceptions

        } catch (SQLException e) {
            log.error("{} SQL {}", tableName, sqlInsert);
            log.error("{} SQL Batch Insert error", tableName, e);
            debugErrors(persistenceContext, e);
            throw new RuntimeException(e);
        } finally {
            SQLUtils.closeQuietly(stmt);
        }

    }

    public <T extends IEntity> boolean insertBulk(PersistenceContext persistenceContext, Iterable<T> entityIterable) {
        PreparedStatement stmt = null;
        int[] vals = null;
        StringBuilder sql = new StringBuilder();
        try {
            sql.append("INSERT INTO ");
            sql.append(getFullTableName());
            sql.append(sqlInsert());
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            boolean hasKeys = (getPrimaryKeyStrategy() == Table.PrimaryKeyStrategy.ASSIGNED);
            stmt = persistenceContext.getConnection().prepareStatement(sql.toString());
            for (T entity : entityIterable) {
                int parameterIndex = 1;
                parameterIndex = bindPersistParameters(parameterIndex, persistenceContext, stmt, entity);
                if (hasKeys) {
                    stmt.setLong(parameterIndex, entity.getPrimaryKey().asLong());
                    parameterIndex++;
                }
                if (dialect.isMultitenantSharedSchema()) {
                    stmt.setString(parameterIndex, NamespaceManager.getNamespace());
                    parameterIndex++;
                }
                stmt.addBatch();
            }
            persistenceContext.setUncommittedChanges();
            vals = stmt.executeBatch(); // INSERTs
            for (int i = 0; i < vals.length; i++) {
                if (vals[i] == 0) {
                    // not inserted ???
                }
            }
            return true; //good, we reached this without exceptions
        } catch (SQLException e) {
            log.error("{} SQL {}", tableName, sql);
            log.error("{} SQL Batch Insert error", tableName, e);
            throw new RuntimeException(e);
        } finally {
            SQLUtils.closeQuietly(stmt);
        }

    }

    public <T extends IEntity> void persist(PersistenceContext persistenceContext, Iterable<T> entityIterable, List<T> notUpdated) {
        PreparedStatement stmt = null;
        int[] vals = null;
        Vector<T> all = new Vector<T>();
        StringBuilder sql = new StringBuilder();
        try {
            sql.append("UPDATE  ");
            sql.append(getFullTableName());
            sql.append(sqlUpdate());
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            stmt = persistenceContext.getConnection().prepareStatement(sql.toString());
            // zero means there is no limit, Need for pooled connections
            stmt.setMaxRows(0);
            for (T entity : entityIterable) {
                if (entity.getPrimaryKey() == null) {
                    // persist(Connection connection, Iterable<T> entityIterable) should be called on entities with non-NULL PKs
                    // ??? log.error(" persist(Connection connection, Iterable<T> entityIterable) should be called on entities with non-NULL PKs", tableName);
                    throw new RuntimeException();
                }
                int parameterIndex = 1;
                parameterIndex = bindPersistParameters(parameterIndex, persistenceContext, stmt, entity);
                stmt.setLong(parameterIndex, entity.getPrimaryKey().asLong());
                if (dialect.isMultitenantSharedSchema()) {
                    parameterIndex++;
                    stmt.setString(parameterIndex, NamespaceManager.getNamespace());
                }
                stmt.addBatch();
                all.add(entity);
            }
            persistenceContext.setUncommittedChanges();
            vals = stmt.executeBatch(); // UPDATE
            for (int i = 0; i < vals.length; i++) {
                if (vals[i] == Statement.EXECUTE_FAILED) {
                    //////  WE MUST ROLL-BACK ////////////////////////////////
                    // due to executeBatch() may or may not throw BatchUpdateException, (see docs/api/java/sql/Statement.html#executeBatch())
                    // rather than duplicate code, we throw BatchUpdateException and have
                    // code in a single place to handle failure
                    //log.error("{} executeBatch update error", tableName, e); //  I'd like to log something, to see if a DB throws or not
                    throw new java.sql.BatchUpdateException();
                }
                if (vals[i] == 0) {
                    notUpdated.add(all.get(i));
                }
            }
        } catch (SQLException e) {
            log.error("{} SQL update error", tableName, e);
            debugErrors(persistenceContext, e);
            throw new RuntimeException(e);
        } finally {
            SQLUtils.closeQuietly(stmt);
        }

    }

    public <T extends IEntity> boolean retrieve(PersistenceContext persistenceContext, Map<Key, T> entities) {
        StringBuilder sql = new StringBuilder();
        sql.append("SELECT * FROM ").append(getFullTableName()).append(" WHERE ").append(dialect.getNamingConvention().sqlIdColumnName()).append(" IN (");
        int count = 0;
        for (Key primaryKey : entities.keySet()) {
            if (count != 0) {
                sql.append(',');
            }
            sql.append(primaryKey);
            count++;
        }
        sql.append(')');
        if (dialect.isMultitenantSharedSchema()) {
            sql.append(" AND ").append(dialect.getNamingConvention().sqlNameSpaceColumnName()).append(" = ?");
        }

        PreparedStatement stmt = null;
        ResultSet rs = null;
        try {
            if (PersistenceTrace.traceSql) {
                log.debug("{}{} {}\n\tfrom:{}\t", Trace.id(), persistenceContext.txId(), sql, Trace.getCallOrigin(EntityPersistenceServiceRDB.class));
            }
            stmt = persistenceContext.getConnection().prepareStatement(sql.toString());
            // zero means there is no limit, Need for pooled connections
            stmt.setMaxRows(0);
            if (dialect.isMultitenantSharedSchema()) {
                stmt.setString(1, NamespaceManager.getNamespace());
            }

            rs = stmt.executeQuery();
            for (int i = 0; i < count; i++) {
                rs.next();
                Key key = new Key(rs.getLong(dialect.getNamingConvention().sqlIdColumnName()));
                if (!entities.containsKey(key)) {
                    throw new RuntimeException();
                }
                if ((dialect.isMultitenantSharedSchema())
                        && !rs.getString(dialect.getNamingConvention().sqlNameSpaceColumnName()).equals(NamespaceManager.getNamespace())) {
                    throw new RuntimeException("namespace acess error");
                }
                T entity = entities.get(key);
                entity.setPrimaryKey(key);
                TableModel subclassModel = retrieveDiscriminator(persistenceContext, rs, entity);
                subclassModel.retrieveValues(rs, entity.cast());
                subclassModel.retrieveExternal(persistenceContext, entity.cast(), AttachLevel.Attached);
            }
            return true;
        } catch (SQLException e) {
            log.error("{} SQL select error", tableName, e);
            debugErrors(persistenceContext, e);
            throw new RuntimeException(e);
        } finally {
            SQLUtils.closeQuietly(rs);
            SQLUtils.closeQuietly(stmt);
        }
    }

}
